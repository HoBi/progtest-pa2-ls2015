<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.8.9.1">
  <compounddef id="assignment" kind="page">
    <compoundname>assignment</compoundname>
    <title>Assignment (czech)</title>
    <detaileddescription>
<para>Úkolem je rozšířit třídu <ref refid="class_c_register" kindref="compound">CRegister</ref> z předešlé úlohy tak, aby správně kopírovala obsah objektů při použití kopírujícího konstruktoru a operátoru =.</para><para>Naše databáze bude evidovat občany a automobily, které vlastní. Občan je identifikován svým jménem a příjmením. Jména a příjmení se mohou opakovat, ale dvojice (jméno, příjmení) je v databázi unikátní. Tedy v databázi může být mnoho jmen Jan a mnoho příjmení Novak, ale Jan Novak může být v databázi v daný okamžik pouze jeden. Automobily jsou pak jednoznačně identifikované svojí registrační značkou RZ. Předpokládáme, že automobil má vždy jednoho vlastníka, jeden občan může vlastnit několik automobilů.</para><para>Z důvodů zálohování chceme mít možnost vytvářet kopie existujícího instance <ref refid="class_c_register" kindref="compound">CRegister</ref>. Kopie budou vznikat jednak kopírujícím konstruktorem a dále i operátorem =. Vzniklé kopie musí být nezávislé objekty, tedy operace s jedním z nich nemůže ovlivnit obsah druhého. Na druhou stranu se dá počítat s tím, že změn mezi kopiemi nebude mnoho, tedy některá data mohou kopie sdílet v zájmu šetření místa.</para><para>Veřejné rozhraní je uvedeno níže. Pro třídu <ref refid="class_c_register" kindref="compound">CRegister</ref> obsahuje následující:</para><para><itemizedlist>
<listitem><para>Konstruktor bez parametrů. Tento konstruktor inicializuje instanci třídy tak, že vzniklá instance je zatím prázdná (neobsahuje žádné záznamy). </para></listitem>
<listitem><para>Destruktor. Uvolňuje prostředky, které instance alokovala. </para></listitem>
<listitem><para>Kopírující konstruktor a operátor = bude správně kopírovat obsah objektu. </para></listitem>
<listitem><para>Metoda AddCar(RZ, Name, Surname) přidá do existující databáze další záznam. Parametry Name a Surname reprezentují jméno a příjmení občana, RZ je identifikace automobilu. Metoda vrací hodnotu true, pokud byl záznam přidán, nebo hodnotu false, pokud dojde k chybě a automobil přidán nebyl. Chybou je, pokud již v databázi existuje automobil se stejnou RZ. </para></listitem>
<listitem><para>Metoda DelCar (RZ) odstraní záznam z databáze. Parametrem je jednoznačná identifikace automobilu pomocí RZ. Pokud byl záznam skutečně odstraněn, vrátí metoda hodnotu true. Pokud záznam neodstraní (protože neexistoval automobil s touto identifikací), vrátí metoda hodnotu false. </para></listitem>
<listitem><para>Metoda Transfer ( RZ, name, surname ) provede převod zadaného automobilu (RZ) ze stávajícího majitele na nového majitele zadaného parametry name a surname. Pokud metoda uspěje, vrací true, pro neúspěch vrací false (neexistující automobil, chybou je i pokus o převod, kdy stávající a nový majitel je ten samý občan). </para></listitem>
<listitem><para>Metoda ListCars vyhledá automobily, které jsou vlastněné zadaným občanem. Metoda vrátí objekt typu <ref refid="class_c_car_list" kindref="compound">CCarList</ref>, pomocí kterého lze postupně projít nalezené záznamy (iterátor). Pokud občan zadaného jména a příjmení neexistuje, je vrácen iterátor s prázdným obsahem (0 automobilů). </para></listitem>
<listitem><para>Metoda CountCars ( name, surname ) zjistí počet automobilů, který vlastní občan se zadaným jménem a adresou. Pokud občan zadaného jména v databázi neexistuje, je vrácena 0. </para></listitem>
<listitem><para>Metoda ListOwners (RZ) vyhledá osoby, které vlastnily (vlastní) zadaný automobil. Metoda vrátí objekt typu <ref refid="class_c_owner_list" kindref="compound">COwnerList</ref>, pomocí kterého lze postupně projít nalezené záznamy (iterátor). Pokud zadaný automobil neexistuje, je vrácen iterátor s prázdným obsahem (0 osob). </para></listitem>
<listitem><para>Metoda CountOwners (RZ) zjistí počet majitelů v historii vlastnictví zadaného automobilu. Pokud zadaný automobil v databázi neexistuje, je vrácena 0. </para></listitem>
<listitem><para>Do třídy si budete muset přidat členské proměnné. Dále si do rozhraní můžete přidat další pomocné metody (ideálně neveřejné).</para></listitem>
</itemizedlist>
Třída <ref refid="class_c_car_list" kindref="compound">CCarList</ref> slouží k jednorázovému procházení seznamem automobilů, které jsou vlastněné jedním občanem. V seznamu je vždy jeden automobil vybraný a v seznamu se můžeme pohybovat vpřed. Rozhraní třídy <ref refid="class_c_car_list" kindref="compound">CCarList</ref>:</para><para><itemizedlist>
<listitem><para>Metoda RZ zjistí RZ vybraného automobilu, </para></listitem>
<listitem><para>metoda AtEnd zjistí, zda jsme již dosáhli konce seznamu (vrátí true) nebo zda jsou ještě nějaké záznamy k dispozici (false). </para></listitem>
<listitem><para>Metoda Next posouvá v seznamu o jednu pozici směrem ke konci.</para></listitem>
</itemizedlist>
Třída <ref refid="class_c_owner_list" kindref="compound">COwnerList</ref> slouží k jednorázovému procházení seznamem vlastníků, kteří vlastnili/vlastní zadaný automobil. V seznamu je vždy jeden vlastník aktuální a v seznamu se můžeme pohybovat vpřed. První v pořadí musí být aktuální vlastník, při procházení se pak pohybujeme směrem zpět do historie. Rozhraní třídy <ref refid="class_c_owner_list" kindref="compound">COwnerList</ref>:</para><para><itemizedlist>
<listitem><para>Metoda Name zjistí jméno vybraného vlastníka, </para></listitem>
<listitem><para>Metoda Surname zjistí příjmení vybraného vlastníka, </para></listitem>
<listitem><para>metoda AtEnd zjistí, zda jsme již dosáhli konce seznamu (vrátí true) nebo zda jsou ještě nějaké záznamy k dispozici (false). </para></listitem>
<listitem><para>Metoda Next posouvá v seznamu o jednu pozici směrem ke konci (zpět v historii).</para></listitem>
</itemizedlist>
Odevzdávejte soubor, který obsahuje implementované třídy <ref refid="class_c_register" kindref="compound">CRegister</ref>, <ref refid="class_c_car_list" kindref="compound">CCarList</ref> a <ref refid="class_c_owner_list" kindref="compound">COwnerList</ref>. Třídy musí splňovat veřejné rozhraní podle ukázky - pokud Vámi odevzdané řešení nebude obsahovat popsané rozhraní, dojde k chybě při kompilaci. Do třídy si ale můžete doplnit další metody (veřejné nebo i privátní) a členské proměnné. Odevzdávaný soubor musí obsahovat jak deklaraci třídy (popis rozhraní) tak i definice metod, konstruktoru a destruktoru. Je jedno, zda jsou metody implementované inline nebo odděleně. Odevzdávaný soubor nesmí obsahovat vkládání hlavičkových souborů a funkci main (funkce main a vkládání hlavičkových souborů může zůstat, ale pouze obalené direktivami podmíněného překladu jako v ukázce níže).</para><para>Třída je testovaná v omezeném prostředí, kde je limitovaná dostupná paměť (dostačuje k uložení seznamu) a je omezena dobou běhu. Pro řešení zcela záměrně nemáte k dispozici STL ani std::string. Úloha má procvičit pochopení hluboké a mělké kopie. S využitím STL by tento cíl nebyl naplněn.</para><para>Hodnocení je rozděleno mezi povinné, nepovinné a bonusové testy. Pro zvládnutí povinných testů stačí implementace základní verze kopírování obsahu. Pro zvládnutí dalších testů je potřeba využít techniky copy-on-write, aby vznikající kopie zabíraly rozumný objem paměti. </para>    </detaileddescription>
  </compounddef>
</doxygen>
